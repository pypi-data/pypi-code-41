#!/usr/bin/python3
import argparse
import boto3
import datetime
import getpass
import json
import logging
import os
import sys
import pathlib
import pkg_resources

HOME = str(pathlib.Path.home())
AWS_CACHE_BASTION = "{}/.aws/cli/cache/bastion.json".format(HOME)

def parse_arguments():
    description = "bastion extends the default behavior of using an IAM role in the awscli by caching STS credentials for up to 12 hours. Then we can securely use IAM roles with the awscli through the bastion account without needing to re-enter the mfa code."
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-m", "--mfa-code", help="the mfa code used to get the sts session credentials", nargs="?", default=None)
    parser.add_argument("-p", "--profile", help="the profile containing the long-lived IAM credentials (default: %(default)s)", default="bastion")
    parser.add_argument("-s", "--profile-sts", help="the profile that assume role profiles will depend on (default: %(default)s)", default="bastion-sts")
    parser.add_argument("-r", "--region", help="the region used when creating new AWS connections (default: %(default)s)", default="us-west-2")
    parser.add_argument("-l", "--log-level", help="the log level threshold for the python logger (default: %(default)s)", default=None, choices=["CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG", "NOTSET", None])
    parser.add_argument('-d', '--debug', help='Enable debug mode to see all python stack traces.', action='store_true')
    parser.add_argument("-v", "--version", action="version",
        version=pkg_resources.get_distribution("aws_bastion").version)
    return parser.parse_args()

def get_mfa_serial(session, args, logger):
    mfa_serial = None
    try:
        iam = session.client('iam')
        username = iam.get_user()["User"]["UserName"]

        for iam_mfa_device in iam.list_mfa_devices(UserName=username)["MFADevices"]:
            mfa_serial = iam_mfa_device["SerialNumber"]
            break   # no need to check another MFA device.
        else:
            if logger:
                logger.error("failed to get mfa device from current iam user")
            raise Exception
    except Exception as _:
        try:
            import configparser
            config = configparser.ConfigParser()
            config.read("{}/.aws/credentials".format(HOME))
            mfa_serial = config[args.profile_sts]["mfa_serial"]
        except Exception as _:
            if logger:
                logger.critical("failed to get mfa device from the {} profile".format(args.profile_sts))
    return mfa_serial

def get_sts_creds(session, mfa_code, mfa_serial):
    creds = session.client("sts").get_session_token(
        DurationSeconds=datetime.timedelta(hours=12).seconds,
        SerialNumber=mfa_serial,
        TokenCode=mfa_code
    )["Credentials"]

    return {
        "AccessKeyId": creds["AccessKeyId"],
        "SecretAccessKey": creds["SecretAccessKey"],
        "SessionToken": creds["SessionToken"],
        "Version": 1}

def set_cache(creds):
    with open(AWS_CACHE_BASTION, 'w+') as f:
        json.dump(creds, f, indent=4)

def get_cache():
    with open(AWS_CACHE_BASTION, 'r') as f:
        return json.load(f)

def bastion(args, logger):
    if os.path.isfile(AWS_CACHE_BASTION):
        creds = get_cache()
    else:
        session = boto3.Session(profile_name=args.profile, region_name=args.region)
        mfa_serial = get_mfa_serial(session, args, logger)
        if args.mfa_code:
            mfa_code = args.mfa_code
        else:
            mfa_code = getpass.getpass("Enter MFA code for {}: ".format(mfa_serial))
        creds = get_sts_creds(session, mfa_code, mfa_serial)

    set_cache(creds)
    print(json.dumps(creds))

def main(args=None):
    args = parse_arguments()
    print(args)

    logger = None
    if args.log_level:
        logging.basicConfig(level=getattr(logging, args.log_level))
        logger = logging.getLogger()

    if args.debug:
        bastion(args, logger)
    else:
        try:
            bastion(args, logger)
        except Exception as e:
            print(str(e))

if __name__ == "__main__":
    main()
